[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The SQL Cheat Sheet",
    "section": "",
    "text": "Definition: A relational database defines relationships between tables of data inside the database.\nPossibly the biggest advantage of a database is that many users can write queries to gather insights from the data at the same time. When a database is queried, the data stored inside the database does not change: rather, the database information is accessed and presented according to instructions in the query.\nSQL, or S-Q-L, is short for Structured Query Language. It is the most widely used programming language for creating, querying, and updating relational databases.\nrows = records holds data of an individual observation\ncolumn = fields holds one piece of information about all records, same data type in one field like number, text or date for example. We use data types for several reasons. First, different types of data are stored differently and take up different amounts of storage space. Second, some operations only apply to certain data types. It makes sense to multiply a number by another number, but it does not make sense to multiply text by other text for example. Types are string, integers or floats. The NUMERIC data type can store floats which have up to 38 digits total - including those before and after the decimal point.\nunique identifier (“key”), identify records in a table to identify this record, often a number, often at the leftest of the table\nquery request from data from a database.\nschema (“blue prints”), shows a database’s design, such as what tables are included in the database and any relationships between its tables. A schema also lets the reader know what data type each field can hold.\n\nGood table names manners table name: lowercase,no spaces _ instead, plural or collective group name\nfield name: lowercase, no spaces, singular, unique in a table.\nHaving more tables, each with a clearly marked subject, is generally better than having fewer tables where information about multiple subjects is combined.\n\n\nKeywords are reserved words used to indicate what operation we’d like our code to perform.\nSELECT keyword indicates which fields should be selected - in this case, the name field.\nFROM keyword indicates the table in which these fields are located - in this case, the patrons table.\nEnd the query with a ; to indicate it is compete\nSELECT field_name1,field_name2,fieldname_n\nFROM table_name;\nresults called result set, lists all the column information from one table. The sorting of field names does not change the sorting in the results.\nIf we want all field names of a table we can use *\n\n\n\nSQL has a few different versions, or flavors. Some are free, while others have customer support and are made to complement major databases such as Microsoft’s SQL Server or Oracle Database, which are used by many companies. All SQL flavors are used with table-based relational databases like the ones we’ve seen, and the vast majority of keywords are shared between them! In fact, all SQL flavors must follow universal standards set by the International Organization for Standards and the American National Standards Institute. Only additional features on top of these standards result in different SQL flavors. Think of SQL flavors as dialects of the same language.\nMost popular\nPstgreSQL\n- free & open source, created by University of California - The name “PostgreSQL” is used to refer to both the database system itself as well as the SQL flavor used with it. SQL Server - free and paid versions - SQL Server is also a relational database system which comes in both free and enterprise versions. It was created by Microsoft, so it pairs well with other Microsoft products. T-SQL is Microsoft’s proprietary flavor of SQL, used with SQL Server databases.\n\n\nLimits the records, that are shown.\nIn PostgreSQL: SELECT field_name1,field_name2 FROM table_name LIMIT number_records;\nIn SQL Server: SELECT TOP(2) field_name1, field_name2 FROM table_name;\n\n\n\n\nFormating\nSQL is a generous language when it comes to formatting. New lines, capitalization, and indentation are not required in SQL as they sometimes are in other programming languages. Although, formating is useful to make code more readible and debug it easier. While keyword capitalization and new lines are standard practice, many of the finer details of SQL style are not. For instance, some SQL users prefer to create a new line and indent each selected field when a query selects multiple fields, as the query on this slide does. Because of different styles follow a style guide.\nSometimes field names not follows the style guide. If you want to refer to a fieldname with for example a spaces in it use double-quotes.\nSELECT \"release date\"\nFROM films;\nOrder of execution\nUnlike many programming languages, SQL code is not processed in the order it is written.\nStep 1: FROM\nStep 2: INNER JOIN, LEFT JOIN, RIGHT JOIN\nStep 3: WHERE (filter without aggregate function, only for individuals)\nSTEP 4: SELECT (aliases are defined here), (arethmetic is included here), (round is included here)\nSTEP 5: GROUP BY\nStep 6: HAVING (filter for grouped records)\nSTEP 7: ORDER BY (only here alias assigned in Step 3 can be used!)\nSTEP 8: LIMIT\n\n\nSometimes it can be helpful to rename columns in our result set, whether for clarity or brevity. We can do this using aliasing. Therefore we can use AS. So, if we want to rename the first column_name in our result set we type:\nSELECT field_name1 AS new_name, field_name2, field_name\nFROM table_name;\nAttention! Does not change the name in the original table, only in the result table!\n\n\n\nIf you only want unique values of a column, type:\nSELECT DISTINCT field_name1\nFROM table_name;\nAlso applies for several fields, maybe if you want to investigate which department appoint new employees in which year. In consequence, you only get unique combinations!\nSELECT DISTINCT field_name1, field_name2\nFROM table_name;\n\n\n\nView refers to a table that is the result of a saved SQL SELECT statement. Views are considered virtual tables, which means that the data a view contains is not generally stored in the database. Rather, it is the query code that is stored for future use. A benefit of this is that whenever the view is accessed, it automatically updates the query results to account for any updates to the underlying database. To create a view, we’ll add a line of code before the SELECT`statement:CREATE VIEW, then the name we'd like for the new view, then theAS` keyword to assign the results of the query to the new view name.\nCREATE VIEW view_name  AS\nSELECT  field_name1, field_name2\nFROM table_name;\nThere is no result set when creating a view. Once a view is created, however, we can query it just as we would a normal table by selecting FROM the view.\n\nUsing views\n\nView the results you’ve created with\nSELECT * FROM view_name;\n\n\n\nThe COUNT function lets us do this by returning the number of records with a value in a field.\n#How many records of birthdates are in the table people?\nSELECT COUNT (birtdates) AS count_birthdates\nFROM people;\n#for more than one field, count the number of birthdates and the number of names\nSELECT COUNT(name) AS count_names, COUNT(birthdate) AS count_birthdates\nFROM people;\n# get the number of records from a table\nSELECT COUNT(*) AS total_records\nFROM people;\nOften, our results will include duplicates. We can use the DISTINCT keyword to select all the unique values from a field.\n#get unique values in a field, how many unique languages are in the films table?\nSELECT DISTINCT language\nFROM films;\n#or use COUNT instead for get the number of distinct birthdates in a table\nSELECT COUNT(DISTINCT birthdate) AS count_dis_birth\nFROM people;\n\n\n\nUse the keyword WHERE to filter records which met certain conditions.\nFor numbers use the following operators:\n#for all titles with a release year SMALLER THAN 1960\nSELECT title\nFROM films\nWHERE release_year &lt; 1960;\n\n# for all GREATER THAN or EQUAL TO\nSELECT title\nFROM films\nWHERE release_year &gt;= 1960;\n\n#for a SPECIFIC year\nSELECT title\nFROM films\nWHERE release_year = 1960;\n\n# for all films EXCEPT 1960, NOT EQUAL TO\nSELECT title\nFROM films\nWHERE release_year &lt;&gt; 1960;\nFor strings use single-quotes:\n#for all titles that have been created in Japan\nSELECT title\nFROM films\nWHERE country = 'Japan';\nIf we want to combine WHERE with other key words, this is the order:\n#for all titles that have been created in Japan\nSELECT title\nFROM films\nWHERE country = 'Japan'\nLIMIT 5;\nMore than one condition:\n# one AND another conditions\nSELECT title\nFROM films\nWHERE country = 'Japan' AND release_year &lt;&gt; 1960;\n\n# one OR another condition is true\nSELECT title\nFROM films\nWHERE country = 'Japan' OR release_year &lt;&gt; 1960;\n\n# records are BETWEEN a range of numbers\nSELECT title\nFROM films\nWHERE release_year BETWEEN 1966 AND 1988;\n\n    # BETWEEN works inclusive, means its the same as the following\n    SELECT TITLE\n    FROM films\n    WHERE release_year &gt;= 1994\n        AND release_year &lt;= 2000'; \n\n# combine OR and AND\nSELECT title\nFROM films\nWHERE (release_year &lt;&gt; 1960 OR release_year &lt;&gt; 1961)\n    AND (certification= 'PG' OR ceritifcation = 'R');\nWhat if we are not interested that a string matches a specific word, but a pattern? We can look for this with LIKE, NOT LIKE. Therefore we use wildcards. % match zero, one or many characters. _ match a single character.\n#get all names, which started with Ad\nSELECT name\nFROM people\nWHERE name LIKE 'Ad%';\n\n#get all names, which started with Ev and has only three letters\nSELECT name\nFROM people\nWHERE name LIKE 'Ev_';\n\n#NOT LIKE is the inversion of LIKE, so it gives all records that not have a 'von' in its name\nSELECT name\nFROM people\nWHERE name NOT LIKE '%von%;\n\n# its also possible to combine the wildcards, so in a case where we want to get all names, where a 'ma' comes in the third position\nSELECT name\nFROM people\nWHERE name NOT LIKE '__ma%';\nWhat if we want to filter based on many conditions or a range of numbers? Then, we can use the IN operator, which allows us to specify multiple values in a WHERE clause, making it easier and quicker to set numerous OR conditions.\n#get all films from 1920, 1930 or 1940\nSELECT title\nFROM films\nWHERE release_year IN (1920,1930,1940);\n\n    #its the same as this but way easier:\n    SELECT title\n    FROM films\n    WHERE release_year=1920\n    OR release_year=1930\n    OR release_year=1940;\n\n#also possible for strings\nSELECT title\nFROM films\nWHERE country IN ('Germany', 'France');\n\n\n\nWhen we were learning how to use the COUNT keyword, we learned that we could include or exclude non-missing values depending on whether or not we use the asterisk in our query. But what is a missing or non-missing value? In SQL, null represents a missing or unknown value. COUNT(*) counts all records including missing values. Pay attention! COUNT(field_name counts only all given values and filter out the missings. Hence, we don’t want to jump to false conclusions, its important to access, how much data is missing. Thus, we add IS NULL to the WHERE clause. Often we want to filter out missing values. Therefore we can use IS NOT NULL.\n# how many birthdates are missing in the data base?\nSELECT COUNT(*) AS no_birthdates\nFROM people\nWHERE birthdate IS NULL;\n# if we want to filter out missing values for our counting\nSELECT COUNT(*) AS birthdates_yes\nFROM people\nWHERE birthdate IS NOT NULL;\n    # we can also filter out all null values in specifying our count\n    SELECT COUNT(birthdates) AS birthdates_yes\n    FROM people; \n\n\n\nWe already know one aggregate function, COUNT()! We’ll now learn four new aggregate functions, allowing us to find the average, sum, minimum, and maximum of a specified field, not records!\nfor numeric SUM() gives the sum AVG() gives the average\nFor various data types\nCOUNT() count the given values, can provide a total of any non-missing, or not null, records in a field regardless of their type.\nMIN() gives the minimum or MAX() gives the maximum, similarly, minimum and maximum will give the record that is figuratively the lowest or highest. Lowest can mean the letter A when dealing with strings or the earliest date when dealing with dates. And, of course, with numbers, it is the highest or the lowest number.\nBest practice is to use an alias Notice how all query results have automatically updated the field name to the function. In this case, min. It’s best practice to use an alias when summarizing data so that our results are clear to anyone reading our code.\n#for numeric data find the total duration of all films\nSELECT SUM(duration) AS total_duration\nFROM films\n\n#find the shortest film\nSELECT (duration) AS shortest_film \nFROM films;\n\n\nWe can combine aggregate functions with the WHERE clause to gain further insights from our data. That’s because the WHERE clause executes before the SELECT statement. For example, to get the average budget of movies made in 2010 or later, we would select the average of the budget field from the films table where the release year is greater than or equal to 2010.\n#get the minimum budget for all films released in 2010.\nSELECT MIN (budget) AS min_budget\nFROM films\nWHERE release_year =2010;\n\n#also possible with count, how many given values (not missing) do we have for film budgets, where films have been released in 2010?\nSELECT COUNT(budget) AS count_budget\nFROM films\nWHERE release_year = 2010;\n\n#you can also have more than one aggregate function applied\n#Modify the query to also list the average budget and average gross\nSELECT release_year,AVG(budget) AS avg_budget, AVG(gross) AS avg_gross\nFROM films\nWHERE release_year &gt; 1990\n\n\n\n\nIn SQL, we can use ROUND() to round our number to a specified decimal. There are two parameters for ROUND(): the number we want to round and the decimal place we want to round to. ROUND(number_to_round, decimal_places). decimal_places are optional. If no value is given, it treats the key word like you assigned a zero and it is rounded to a whole number. Using negative five as the decimal place parameter will cause the function to round to the hundred thousand or five places to the left. ROUND() can only be used with numerical fields.\n#let's round the average with 2 decimal places\nSELECT ROUND(AVG(budget),2) AS avg_budget\nFROM films\nWHERE release_year = 2010;\n\n\n\nWe can perform basic arithmetic with symbols like plus, minus, multiply, and divide. Using parentheses with arithmetic indicates to the processor when the calculation needs to execute.\nSimilar to other programming languages, SQL assumes that we want to get an integer back if we divide an integer by an integer. So be careful! When dividing, we can add decimal places to our numbers if we want more precision.\n#only get a whole number\nSELECT(4/3);\n\n#get one decimal place\nSELECT(4.0/3.0);\nWhat’s the difference between using aggregate functions and arithmetic? The key difference is that aggregate functions, like SUM, perform their operations on the fields vertically while arithmetic adds up the records horizontally. Notice that the query’s result doesn’t give us a defined field name. We will always need to use an alias when summarizing data with aggregate functions and arithmetic.\n# what is the gap between what a movie has made and a movie had cost?\nSELECT (gross-budget) AS profit\nFROM films;\n\nExamples.\n#Round duration_hours to two decimal places\nSELECT title, ROUND(duration / 60.0, 2) AS duration_hours\nFROM films;\n\n\n\nSorting results means we want to put our data in a specific order. It’s another way to make our data easier to understand by quickly seeing it in a sequence. Therefore, use ORDER BY. It will sort in ascending order by default (small to high number, number or special signs to A to Z). If you want to change the order to descending, than use DESC after the field name. When used on its own, itws written after the FROM statement. Attention! For numbers null / a missing value is the highest one. So you need to add a WHERE clause.\nNotice that we don’t have to select the field we are sorting on. For example, here’s a query where we sort by release year and only look at the title. However, it is a good idea to include the field we are sorting on in the SELECT statement for clarity.\n#get all titles and budgets, sorted descending by budget\nSELECT title, budget\nFROM films\nORDER BY budget DESC;\n\n#without missing values\nSELECT title, budget\nFROM films\nWHERE budget IS NOT NULL\nORDER BY budget DESC;\nORDER BY can also be used to sort on multiple fields. It will sort by the first field specified, then sort by the next, etc. To specify multiple fields, we separate the field names with a comma. The second field we sort by can be thought of as a tie-breaker when the first field is not decisive in telling the order.\n# what are the best movies? First sort by oscar wins. this is not sufficient, because several movies have won same often an oscar. Therefore, use the imdb score as a tie-breaker\nSELECT title, wins\nFROM best_movies\nWHERE budget IS NOT NULL\nORDER BY wins DESC, imdb_score DESC;\n\n# its also possible to select different orders for each field we are sorting.\nSELECT birthdate, name\nFROM people\nORDER BY birthdate, name DESC;\n\n\n\nGroup with GROUP BY. It is commonly used with aggregate functions to provide summary statistics, particularly when only grouping a single field, certification, and selecting multiple fields, certification and title. This is because the aggregate function will reduce the non-grouped field to one record only, which will need to correspond to one group.\nSQL will return an error if we try to SELECT a field that is not in our GROUP BY clause. We’ll need to correct this by adding an aggregate function around title.\nWe can use GROUP BY on multiple fields similar to ORDER BY. The order in which we write the fields affects how the data is grouped. The query here selects and groups certification and language while aggregating the title. The result shows that we have five films that have missing values for both certification and language, two films that are unrated and in Japanese, two films that are rated R and in Norwegian, and so on.\n# Example with COUNT\nSELECT certification, language, COUNT(title) AS title_count\nFROM films\nGROUP BY certification, language;\n\n#Example with AVG\nSELECT release_year, AVG(duration) AS avg_duration\nFROM films\nGROUP BY release_year;\n\n\n\n\nWe can combine GROUP BY with ORDER BY to group our results, make a calculation, and then order our results.\n#which release year has the highest language diversity?\nSELECT release_year, COUNT(DISTINCT language) AS year_diversity\nFROM films\nGROUP BY release_year\nORDER BY year_diversity DESC;\n\n\n\nWe’ve combined sorting and grouping; next, we will combine filtering with grouping. In SQL, we can’t filter aggregate functions with WHERE clauses. The reason why groups have their own keyword for filtering comes down to the order of execution. WHERE filters individual records while HAVING filters grouped records.\n# in what years was the average duration time above 2 hours?\nSELECT release_year\nFROM films\nGROUP BY release_year\nHAVING AVG(duration &gt; 120);\n#get the country with the distinct certification count greater than 10\nSELECT country, COUNT(DISTINCT(certification)) AS certification_count\nFROM films\nGROUP BY country\nHAVING COUNT(DISTINCT(certification)) &gt; 10;\n\n\n\n\nTables can have different relationsships to each other.\nThe first type of relationship we’ll talk about is a one-to-many relationship. This is the most common type of relationship, one where a single entity can be associated with several entities. Think about a music library. One artist can produce many songs over their career. This is a one-to-many relationship. The same applies for authors and their books, directors and movie titles, and so on.\nA second type of relationship is a one-to-one relationship. One-to-one relationships imply unique pairings between entities and are therefore less common. A commonly held premise of forensic science is that no two fingerprints are identical, and therefore that a particular fingerprint can only be generated by one person. This is an example of a one-to-one relationship: one fingerprint for one finger.\nThe last type of relationship we’ll discuss is a many-to-many relationship. An example of this is languages and countries. Here we show the official languages of Germany, Belgium and the Netherlands, where we see that many languages can be spoken in many countries. For example, Belgium has three official languages: French, German, and Dutch. Conversely, languages can be official in many countries: Dutch is an official language of both the Netherlands and Belgium, but not Germany.\nWith SQL joins, you can join on a key field, or any other field.\n\n\n– is for adding fields together –\nThe INNER JOIN shown looks for records in both tables with the same values in the key field, id. Arrows indicate records where the id matches. The new created table from INNER JOIN only contains records with the same values in the key field from the former tables.\n# define the fields from both tables that we want to have in our output table\nSELECT table_1.field_1, table1.field_2, table.2_field_3, table.2_field_4\n    # table, to which data should be added\nFROM table_1\nINNER JOIN tabel_2\n    # define the key field, in which the same values should be given\nON table_1.keyfield = table_2.keyfield;\nIn our INNER JOIN, we’ve had to type out “table_1” and “table_2” several times. Luckily, we can alias table names using the same AS keyword used to alias column names. If the key field is named the same in both tables, we can use USING.\n# define the fields from both tables that we want to have in our output table\nSELECT t1.field_1, t1.field_2, t2_field_3, t2_field_4\n    # table, to which data should be added\nFROM table_1 AS t1\n    # table from which data should be added\nINNER JOIN table_2 AS t2\n    # define the key field, in which the same values should be given\nUSING (key_field);\n\n#Example\n-- Select fields with aliases\nSELECT c.code AS country_code, c.name,e.year, e.inflation_rate \nFROM countries AS c\n-- Join to economies (alias e)\nINNER JOIN economies AS e\n-- Match on code field using table aliases\nON c.code = e.code;\nA powerful feature of SQL is that multiple joins can be combined and run in a single query. Let’s have a look at some syntax for multiple joins. We begin with the same INNER JOIN as before, and then chain another INNER JOIN to the result of our first INNER JOIN. Notice that we use left_table.id in the last line of this example. If we want to perform the second join using the id field of right_table rather than left_table, we can replace left_table.id with right_table.id in the final line. Only records will be in the output where the same value in the key field is given in all joined tables.\n# SYNTAX\nSELECT *\nFROM left_table\nINNER JOIN right_table\nON left_table.key = righ_table.key\nINNER JOIN next_table\nON left_table_.key/ right_table.key = next_table.key\n\n    # works also with using, here's an example\nSELECT p1.country, p1.continent,president, prime_minister,pm_start\nFROM prime_ministers AS p1\n    # second table\nINNER JOIN presidents AS p2\n    #key word for first inner join\nUSING (country)\n    # third table\nINNER JOIN prime_minister_terms AS p3\n    #key word for second inner join\nUSING (prime_minister);\nWhat if we want to inner join fields by multiple keywords? We can limit the records returned by supplying an additional field to join on by adding the AND keyword to our ON clause. In the following example we join on date, a frequently used second column when joining on multiple fields. The result set now contains records that match on both id AND date.\n# SYNTAX\nSELECT *\nFROM left_table\nINNER JOIN right_table\nON left_table.key = right_table.key\nINNER JOIN next_table\nON left_table_.key/ right_table.key = next_table.key\n    AND left_table.key2 / right_table.key2 = next.table.key2\n\n\n\nOuter joins can obtain records from other tables, even if matches are not found for the field being joined on.\nA LEFT JOIN will return all records in the left_table, and those records in the right_table that match on the joining field provided. Records that are only in the right table provided will faded out. For records, that only appear in the left table, the missing values are set to null in the joined table. LEFT JOIN can also be written as LEFT OUTER JOIN.\n# SYNTAX\nSELECT p1.country, prime_minister, president\nFROM prime_ministers AS p1\nLEFT JOIN presidents AS p2\nUSING (country);\nRIGHT JOINis the second type of outer join, and is much less common than LEFT JOIN so we won’t spend as much time on it here. Instead of matching entries in the id column of the left table to the id column of the right table, a RIGHT JOIN does the reverse. All records are retained from right_table, even when id doesn’t find a corresponding match in left_table. Null values are returned for the left_value field in records that do not find a match.\n# SYNTAX\nSELECT *\nFROM left_table\nLEFT JOIN right table\nON left_table_key = right_table_key; \n\n\n\nA FULL JOIN combines a LEFT JOIN and a RIGHT JOIN. As you can see in this diagram, no values are faded out as they were in earlier diagrams. This is because the FULL JOIN will return all ids, irrespective of whether they have a match in the other table being joined. Note that this time, nulls can appear in either left_value or right_value fields. Note that the keyword FULL OUTER JOIN can also be used to return the same result.\n# SYNTAX\nSELECT left_table_id AS l_id, right_table_id, AS r_idf, left_table_val AS l_val, right_table_val AS r?val\nFROM left_table\nFULL JOIN right table\nUSING id;\n\n\n\nCROSS JOINs are slightly different than joins we have seen previously: they create all possible combinations of two tables. Let’s explore the diagram for a CROSS JOIN. In this diagram we have two tables named table1 and table2, with one field each: id1 and id2, respectively. The result of the CROSS JOINis all nine combinations of the id values of 1, 2, and 3 in table1 with the id values of A, B, and C for table2.\n# SYNTAX\nSELECT field1, field2\nFROM table 1\nCROSS JOIN table 2;\n\n\n\nSelf joins are used to compare values from part of a table to other values from within the same table. Self joins don’t have dedicated syntax as other joins we have seen do. We can’t just write SELF JOIN in SQL code, for example.\nIn addition, aliasing is required for a self join. Let’s look at a chunk of INNER JOIN code using the prime_ministers table. The country column is selected twice, and so is the continent column. The prime_ministers table is on both the left and the right of the JOIN, making this both a self join and an INNER JOIN! The vital step here is setting the joining fields which we use to match the table to itself. For each country, we will find multiple matched countries in the right table, since we are joining on continent. Each of these matched countries will be returned as pairs. Since this query will return several records, we use LIMIT to return only the first 10 records.\n# SYNTAX\nSELECT p1.country AS country1, p2.country AS country2, p1.continent\nFROM prime_ministers AS p1\nINNER JOIN prime_minister AS p2\nON p1.continent = p2.continent\nLIMIT 10;\nThe results are a pairing of each country with every other country in the same continent. However, note that our join also paired countries with themselves, since they too are in the same continent as themselves. We don’t want to include these, since a leader from Portugal does not need to meet with themselves, for example. Let’s fix this. Recall the use of the AND clause to ensure multiple conditions are met in the ON clause. In our second condition, we use the not equal to operator to exclude records where the p1-dot-country and p2-dot-country fields are identical.\n# SYNTAX\nSELECT p1.country AS country1, p2.country AS country2, p1.continent\nFROM prime_ministers AS p1\nINNER JOIN prime_minister AS p2\nON p1.continent = p2.continent\n    # not equal to\n    AND p1.continent &lt;&gt; p2.continent\nLIMIT 10;\n\n\n\nSQL has three main set operations, UNION, INTERSECT and EXCEPT. The Venn diagrams shown visualize the differences between them. We can think of each circle as representing a table. The green parts represent what is included after the set operation is performed on each pair of tables.\n\n\n\n– is for adding records together –\nIn SQL, the UNION operator takes two tables as input, and returns all records from both tables. The diagram shows two tables: left and right, and performing a UNION returns all records in each table. If two records are identical, UNION only returns them once. In SQL, there is a further operator for unions called UNION ALL. In contrast to UNION, given the same two tables, UNION ALL will include duplicate records.\n# SYNTAX\nSELECT t1.field1, t2.field2\nFROM table_1 AS t1\nUNION\nSELECT t1.field1, t2.field2\nFROM table_2 AS t2;\nFor all set operations, the number of selected columns and their respective data types must be identical. For instance, we can’t stack a number field on top of a character field. The result will only use field names (or aliases, if used) of the first SELECT statement in the query.\n\n\n\n\nINTERSECT takes two tables as input, and returns only the records that exist in both tables.\n# SYNTAX\nSELECT t1.field1, t2.field2\nFROM table_1 AS t1\nINTERSECT\nSELECT t1.field1, t2.field2\nFROM table_2 AS t2;\nLet’s compare INTERSECT to performing an INNER JOIN on two fields with identical field names. Similar to UNION, for a record to be returned, INTERSECT requires all fields to match, since in set operations we do not specify any fields to match on. This is also why it requires the left and right table to have the same number of columns in order to compare records. In the figure shown, only records where both columns match are returned. In NNER JOIN, similar to INTERSECT, only results where both fields match are returned. INNER JOIN will return duplicate values, whereas INTERSECT will only return common records once. As we know from earlier lessons, INNER JOIN will add more columns to the result set.\n\n\n\n\nEXCEPT allows us to identify the records that are present in one table, but not the other. More specifically, it retains only records from the left table that are not present in the right table.\n# SYNTAX\nSELECT t1.field1, t2.field2\nFROM table_1 AS t1\nEXCEPT\nSELECT t1.field1, t2.field2\nFROM table_2 AS t2;\n\n\n\n\nCASE statements are SQL’s version of an “IF this THEN that” statement. Case statements have three parts – a WHEN clause, a THEN clause, and anELSE clause. The first part – the WHEN clause – tests a given condition, say, x = 1. If this condition is TRUE, it returns the item you specify after your THEN clause. You can create multiple conditions by listing WHEN and THEN statements within the same CASE statement. The CASE statement is then ended with an ELSE clause that returns a specified value if all of your when statements are not true. When you have completed your statement, be sure to include the term END and give it an alias. The completed CASE statement will evaluate to one column in your SQL query.\n#Identify the home team as Bayern Munich, Schalke 04, or neither\n    #select the hometeam_ids that belongs to the temas and give them the right name\nSELECT \n    CASE WHEN hometeam_id = 10189 THEN 'FC Schalke 04'\n        WHEN hometeam_id = 9823 THEN 'FC Bayern Munich'\n    #select how the others should be called which do not met the condition and define the alias for the field_name of the new table\n         ELSE 'Other' END AS home_team,\n    #count the number of matches and call them total_matches as a field name\n    COUNT(id) AS total_matches\n    #define the table\nFROM matches_germany\n    # Group by the CASE statement alias\nGROUP BY home_team;\n\n# Select the date of  all matches in Spain and identify whether home wins, losses or ties\nSELECT \n    date,\n    CASE WHEN home_goal &gt; away_goal THEN 'Home win!'\n        WHEN home_goal &lt; away_goal THEN 'Home loss :(' \n        ELSE 'Tie' END AS outcome\nFROM matches_spain;\n\n\nPreviously, we covered CASE statements with one logical test in a WHEN statement, returning outcomes based on whether that test is TRUE or FALSE. The former example tests whether home or away goals were higher, and identifies them as wins for the team that had a higher score. Everything ELSE is categorized as a tie. The resulting table has one column identifying matches as one of 3 possible outcomes.\nIf you want to test multiple logical conditions in a CASE statement, you can use AND inside your WHEN clause. For example, let’s see if each match was played, and won, by the team Chelsea. Let’s see the CASE statement in this query. Each WHEN clause contains two logical tests – the first tests if a hometead_id identifies Chelsea, AND then it tests if the home team scored higher than the away team. If both conditions are TRUE, the new column output returns the phrase “Chelsea home win!”. The opposite set of conditions are included in a second when statement – if the awayteam_id belongs to Chelsea, AND scored higher, then the output returns “Chelsea away win!”. All other matches are categorized as a loss or tie. Here’s the resulting table.\n#Example\n#select the date and the ids for the team\nSELECT date, hometeam_id, awayteam_id\n    #test on multiple logical conditions with AND\n    CASE WHEN hometeam_id = 8455 AND home_goal&gt; away_goal THEN 'Chelsea home win!'\n            WHEN awayteam_id = 8455 AND home_goal &lt; away_goal THEN 'Chelsea away win!'\n    ELSE 'Loss or tie:(' END AS outcome\n# define table\nFROM match\n# filter only for records, that you are interested in\nWHERE hometeam_id 8455 OR awayteam_id = 8455;\n\n\n\nWhen testing logical conditions, it’s important to carefully consider which rows of your data are part of your ELSE clause, and if they’re categorized correctly. Here’s the same CASE statement from the previous slide, but the WHERE filter has been removed. Without this filter, your ELSE clause will categorize ALL matches played by anyone, who don’t meet these first two conditions, as “Loss or tie :(”.\n#Example\n#select the date and the ids for the team\nSELECT date, hometeam_id, awayteam_id\n    #test on multiple logical conditions with AND\n    CASE WHEN hometeam_id = 8455 AND home_goal&gt; away_goal THEN 'Chelsea home win!'\n            WHEN awayteam_id = 8455 AND home_goal &lt; away_goal THEN 'Chelsea away win!'\n    ELSE 'Loss or tie:(' END AS outcome\n# define table\nFROM match\n#return all matches and without the filter, all matches without Chelsea are defined as loss or tie\nThe easiest way to correct for this is to ensure you add specific filters in the WHERE clause that exclude all teams where Chelsea did not play. Here, we specify this by using an OR statement in WHERE, which retrieves only results where the id 8455 is present in the hometeam_id or awayteam_id columns. The resulting table from earlier, with the team IDs in bold here, clearly specifies whether Chelsea was home or away team.\n\n\n\nThese two queries here are identical, except for the ELSE NULL statement specified in the second. They both return identical results – a table with quite a few null results. But what if you want to exclude them?\n#without ELSE\nSELECT date,\n    CASE WHEN date&gt; '2015-01-01' THEN 'more recently'\n        WHEN date &lt; '2012-01-01' THEN 'older'\n        END AS date_category\nFROM match;\n\n#with\nSELECT date,\n    CASE WHEN date&gt; '2015-01-01' THEN 'more recently'\n        WHEN date &lt; '2012-01-01' THEN 'older'\n        ELSE NULL END AS date_category\nFROM match;\nLet’s say we’re only interested in viewing the results of games where Chelsea won, and we don’t care if they lose or tie. Just like in the previous example, simply removing the ELSE clause will still retrieve those results – and a lot of NULL values. To correct for this, you can treat the entire CASE statement as a column to filter by in your WHERE clause, just like any other column. In order to filter a query by a CASE statement,\n#Example\n#select the date and the ids for the team\nSELECT date, hometeam_id, awayteam_id\n    #test on multiple logical conditions with AND\n    CASE WHEN hometeam_id = 8455 AND home_goal&gt; away_goal THEN 'Chelsea home win!'\n            WHEN awayteam_id = 8455 AND home_goal &lt; away_goal THEN 'Chelsea away win!'\n    #no ELSE, because we want to have the NULLs in here\n# define table\nFROM match\n# filter only for records, without NULL values at all\nWHERE     CASE WHEN hometeam_id = 8455 AND home_goal&gt; away_goal THEN 'Chelsea home win!'\n            WHEN awayteam_id = 8455 AND home_goal &lt; away_goal THEN 'Chelsea away win!'\n    END IS NOT NULL;\n\n\n\nCASE statements can be used to create columns for categorizing data, and to filter your data in the WHERE clause. You can also use CASE statements to aggregate data based on the result of a logical test.\nCASE statements are like any other column in your query, so you can include them inside an aggregate function. Take a look at the CASE statement. The WHEN clause includes a similar logical test to the previous lesson – did Liverpool play as the home team, AND did the home team score higher than the away team? The difference begins in your THEN clause. Instead of returning a string of text, you return the column identifying the unique match id.\n# What is the number of home games Liverpool (8650) won in each seasion?\nSELECT season,\n    #count only the rows where liverpool has won as a home team\nCOUNT( CASE WHEN home_id = 8650\n                AND home_goal &gt; away_goal THEN id END) AS home_wins\nFROM match\n    #each season\nGROUP BY season;\nSimilarly, you can use the SUM function to calculate a total of any value.\n# what is the number of home and away goals Liverpool scored in each season?\nSELECT season,\n    SUM (CASE WHENhometeam_id= 8650\n            THEN home_goal END) AS home_goals,\n    SUM(CASE WHEN awayteam_id = 8650\n        THEN away_goal END) AS away_goals\nFROM match\n    #each season\nGROUP BY season;\nYou can also use the AVG function with CASE in two key ways. First, you can calculate an average of data. You can do this using CASE in the EXACT same way you used the SUM function.\n# what was the average goals in each season?\nSELECT season,\n    SUM (CASE WHENhometeam_id= 8650\n            THEN home_goal END) AS home_goals,\n    SUM(CASE WHEN awayteam_id = 8650\n        THEN away_goal END) AS away_goals\nFROM match\n    #each season\nGROUP BY season;\n\n#or another way: round it!\nSELECT season,\n    ROUND(AVG(CASE WHEN hometeam_id=8650\n                #round it by two digits\n                THEN home_goal END,2) AS avg_homegoals\n    ROUND(AVG(CASE WHEN awayteam_id=8650\n                #round it by two digits\n                THEN away_goal END,2) AS avg_awaygoals\nFROM match\nGROUB BY season;\nThe second key application of CASE with AVG is in the calculation of percentages. This requires a specific structure in order for your calculation to be accurate.\n# What is the percentage of Liverpools games did they win in each season?\n#select season to be displayed\nSELECT season,\n    #how many games they win as a home team?\n        #the wins\n    ROUND(AVG (CASE WHEN hometeam_id= 8650 AND home_goal &gt; away_goal THEN 1\n            #the losts\n     CASE WHEN hometeam_id= 8650 AND home_goal &lt; away_goal\n            THEN 0 END,2)\n        #averages the wins (1) and losts (0)\n        AS pct_homewins,\n     ROUND(   AVG (CASE WHEN awayteam_id= 8650 AND away_goal &gt; home_goal THEN 1\n            #the losts\n     CASE WHEN awayteam_id= 8650 AND away_goal &lt; home_goal\n            THEN 0 END,2)\n        #averages the wins (1) and losts (0)\n        AS pct_awaywins,\nFROM match\n    #each season\nGROUP BY season;\n\n\n\n\nA subquery is a query nested inside another query. You can tell that there is a subquery in your SQL statement if you have an additional SELECT statement contained inside parentheses, surrounded by another complete SQL statement. So why is this important? Often, in order to retrieve information you want, you have to perform some intermediary transformations to your data before selecting, filtering, or calculating information. Subqueries are a common way of performing this transformation.\n#SYNTAX\nSELECT column\nFROM (SELECT column\n    FROM table) AS subquery;\nA subquery can be placed in any part of your query – such as the SELECT, FROM, WHERE, or GROUP BY clause. Where you place it depends on what you want your final data to look like.\n- Subqueries allow you to compare summarized values to detailed data. For example, compare Liverpool’s performance to the entire English Premier League - Subqueries also allow you to better structure or reshape your data for multiple purposes, such as determining the highest monthly average of goals scored in the Bundesliga. - Finally, subqueries allow you to combine data from tables where you are unable to perform a join, such as getting both the home and away team names into your results table.\nA simple subquery is a query, nested inside another query, that can be run on its own.\nA simple subquery is also evaluated once in the entire query. This means that SQL first processes the information inside the subquery, gets the information it needs, and then moves on to processing information in the OUTER query.\n\n\n\nuseful for filtering results based on information you’d have to calculate separately beforehand.\nonly return a single column\nSubqueries inside WHERE can be from the same table or from a different table\ncould be another way to join information of tables without using join. Now, it is possible to filter the data of one table based on values which are given in another table\n\nWorkflow: - include a SQL subquery as an argument for the IN operator, provided the result of the subquery is of the same data type as the field we are filtering on. - only work if some_field is of the same data type as some_numeric_field, because the result of the subquery will be a numeric field.\nSELECT *\nFROM some_table\nWHERE some_field IN\n    (include subquery here);\nExample: What home_goals where above the average in 2012/2013?\nSELECT date, home_id, away_id, home_goal, away_goal\nFROM match\nWHERE season = '2012/2013'\n    home_goal &gt; \n    #you can run this part on its own!!\n        (SELECT AVG(home_goal)\n         FROM match);\nSubqueries are also useful for generating a filtering list. Example: “Which teams are part of Poland’s league?”\nSELECT team_long_name, team_short_name AS abbr\nFROM team\nWHERE team_api_id IN\n    #filter for poland\n    SELECT home_id\n    FROM match\n    WHERE country_id = 157222);\nThe subquery in WHERE is processed first, generating the overall average of home goals scored. SQL then moves onto the main query, treating the subquery like the single, aggregate value it just generated.\nAnother example, how you can use subqueries to filter one table based on information from another. Determining the presidents of countries that gained independence before 1800.\n# Example\nSELECT president, country, continent\nFROM presidents\nWHERE country IN\n(SELECT country\nFROM states\nWHERE indep_year &lt;1800;\nAlso possible the other way around! The anti join chooses records in the first table where col1 does NOT find a match in col2. Example: How might we adapt our semi join to determine countries in the Americas founded after 1800?\n# Example\nSELECT president, country, continent\nFROM presidents\nWHERE continent LIKE '%Amerika\"\n    AND country NOT IN\n(SELECT country\nFROM states\nWHERE indep_year &lt;1800;\n\n\n\n\nuseful for more complex set of results\nrobust tool for restructuring and transforming your data in a different shape (long to wide format)\nprefilitering before performing calculations\ncalculating aggregates\n\nExample for filtering: all the continents with monarchs, along with the most recent country to gain independence in that continent.\n#Start with pulling the most recent independence years\nSELECT continent, MAX(indep_year) AS most_recent\nFROM states\nGROUP BY continent;\n\n# filter for countries, that have a monarch using SELECT DISTINCT and WHERE to combine the tables and get only the rows, where a row is also given in the monarchs table\nSELECT DISTINCT monarchs.continent, sub.most_recent\nFROM monarchs,\n    (SELECT continent\n     MAX(indep_year) AS most_recent\nFROM states\nGROUP BY continent AS sub\nWHERE monarchs.continent = sub.continent\nExample for averaging: get the top 3 teams based home goal average for each team in data base for season 2011/2012.\n#first create a query, that become the subquery\nSELECT\n    t.team_long_name AS team,\n    AVG (m.home_goal) AS home_avg\nFROM match AS m\nLEFT JOIN team AS t\nON m.home-team_id = t.team_api_id\nWHERE season = '2011/2012'\nGROUP BY team;\n\n#second, to get the top teams only, place this query in a FROM statement of an outer query and give it an alias\nFROM (SELECT\n    t.team_long_name AS team,\n    AVG (m.home_goal) AS home_avg\nFROM match AS m\nLEFT JOIN team AS t\nON m.home-team_id = t.team_api_id\nWHERE season = '2011/2012'\nGROUP BY team) as subquery\n\n#third, add the main query, seceting the team and the home_avg and order them by home_avg, limit with 3 to get only the 3 top results displayes\nSELECT team, home_avg\nFROM (SELECT\n    t.team_long_name AS team,\n    AVG (m.home_goal) AS home_avg\nFROM match AS m\nLEFT JOIN team AS t\nON m.home-team_id = t.team_api_id\nWHERE season = '2011/2012'\nGROUP BY team) as subquery\nORDER BY home_avg DESC\nLIMIT 3;\nTo remember: - you can create multiple subqueries in one FROM statement, give all of them an ALIAS, make sure you are able to join them to each other - you can join a subquery to an existing data base, needs a joining column in both tables!\n\n\n\n\nreturn single, aggregated value\nfairly useful, cause uou cannot include an aggragte value in an ungrouped query\nuseful for performing complex mathematical calculations, e.g. to calculate how an individual score deviates from an average\n\nExample for including aggregates: compare total number of matches played each season with the total number of matches overall.\n#SYNTAX\n# overall number\nSELECT COUNT(id)\nFROM matches;\n\n# add this subquery directly to the select statement\nSELECT season,\n    #for the match each season (combined with the grouping keyword\nCOUNT(id) AS matches,\n(SELECT COUNT(id) FROM match) as total_matches\nFROM match\nGROUP BY season;\nExample for calculations: difference between the overall average numbers of goals scored in a match across all seasons and any given match\n#main query\nSELECT date,\n    #subquery 1: all goals in a game\n(home_goal + away_goal) AS goals,\n    #subquery 2: difference between the goals and the overall average)\n(home_goal + away_goal) - (SELECT(AVG(home_goal + away_goal)  FROM match WHERE season = '2011/2012' AS diff\nFROM match\nWHERE season = '2011/2012';\nTo remember: - subquery needs to return a single value, because information computed in the SELECT query is applied identically to each row in a data set - correct placement of data filters in both the main query and the subquery\n\n\n\nBest practices for readability: - formatting your queries - annotate your with /* what it does, use inline comments -- - indent your queries for better debugging. Make sure that you clearly indent all information that’s part of a single column, such as a long CASE statement, or a complicated subquery in SELECT. - make sure that your filters are properly placed in every subquery, and the main query, in order to generate accurate results."
  },
  {
    "objectID": "index.html#key-words",
    "href": "index.html#key-words",
    "title": "The SQL Cheat Sheet",
    "section": "",
    "text": "Keywords are reserved words used to indicate what operation we’d like our code to perform.\nSELECT keyword indicates which fields should be selected - in this case, the name field.\nFROM keyword indicates the table in which these fields are located - in this case, the patrons table.\nEnd the query with a ; to indicate it is compete\nSELECT field_name1,field_name2,fieldname_n\nFROM table_name;\nresults called result set, lists all the column information from one table. The sorting of field names does not change the sorting in the results.\nIf we want all field names of a table we can use *"
  },
  {
    "objectID": "index.html#sql-flavors",
    "href": "index.html#sql-flavors",
    "title": "The SQL Cheat Sheet",
    "section": "",
    "text": "SQL has a few different versions, or flavors. Some are free, while others have customer support and are made to complement major databases such as Microsoft’s SQL Server or Oracle Database, which are used by many companies. All SQL flavors are used with table-based relational databases like the ones we’ve seen, and the vast majority of keywords are shared between them! In fact, all SQL flavors must follow universal standards set by the International Organization for Standards and the American National Standards Institute. Only additional features on top of these standards result in different SQL flavors. Think of SQL flavors as dialects of the same language.\nMost popular\nPstgreSQL\n- free & open source, created by University of California - The name “PostgreSQL” is used to refer to both the database system itself as well as the SQL flavor used with it. SQL Server - free and paid versions - SQL Server is also a relational database system which comes in both free and enterprise versions. It was created by Microsoft, so it pairs well with other Microsoft products. T-SQL is Microsoft’s proprietary flavor of SQL, used with SQL Server databases.\n\n\nLimits the records, that are shown.\nIn PostgreSQL: SELECT field_name1,field_name2 FROM table_name LIMIT number_records;\nIn SQL Server: SELECT TOP(2) field_name1, field_name2 FROM table_name;"
  },
  {
    "objectID": "index.html#quering-databases",
    "href": "index.html#quering-databases",
    "title": "The SQL Cheat Sheet",
    "section": "",
    "text": "Formating\nSQL is a generous language when it comes to formatting. New lines, capitalization, and indentation are not required in SQL as they sometimes are in other programming languages. Although, formating is useful to make code more readible and debug it easier. While keyword capitalization and new lines are standard practice, many of the finer details of SQL style are not. For instance, some SQL users prefer to create a new line and indent each selected field when a query selects multiple fields, as the query on this slide does. Because of different styles follow a style guide.\nSometimes field names not follows the style guide. If you want to refer to a fieldname with for example a spaces in it use double-quotes.\nSELECT \"release date\"\nFROM films;\nOrder of execution\nUnlike many programming languages, SQL code is not processed in the order it is written.\nStep 1: FROM\nStep 2: INNER JOIN, LEFT JOIN, RIGHT JOIN\nStep 3: WHERE (filter without aggregate function, only for individuals)\nSTEP 4: SELECT (aliases are defined here), (arethmetic is included here), (round is included here)\nSTEP 5: GROUP BY\nStep 6: HAVING (filter for grouped records)\nSTEP 7: ORDER BY (only here alias assigned in Step 3 can be used!)\nSTEP 8: LIMIT\n\n\nSometimes it can be helpful to rename columns in our result set, whether for clarity or brevity. We can do this using aliasing. Therefore we can use AS. So, if we want to rename the first column_name in our result set we type:\nSELECT field_name1 AS new_name, field_name2, field_name\nFROM table_name;\nAttention! Does not change the name in the original table, only in the result table!\n\n\n\nIf you only want unique values of a column, type:\nSELECT DISTINCT field_name1\nFROM table_name;\nAlso applies for several fields, maybe if you want to investigate which department appoint new employees in which year. In consequence, you only get unique combinations!\nSELECT DISTINCT field_name1, field_name2\nFROM table_name;\n\n\n\nView refers to a table that is the result of a saved SQL SELECT statement. Views are considered virtual tables, which means that the data a view contains is not generally stored in the database. Rather, it is the query code that is stored for future use. A benefit of this is that whenever the view is accessed, it automatically updates the query results to account for any updates to the underlying database. To create a view, we’ll add a line of code before the SELECT`statement:CREATE VIEW, then the name we'd like for the new view, then theAS` keyword to assign the results of the query to the new view name.\nCREATE VIEW view_name  AS\nSELECT  field_name1, field_name2\nFROM table_name;\nThere is no result set when creating a view. Once a view is created, however, we can query it just as we would a normal table by selecting FROM the view.\n\nUsing views\n\nView the results you’ve created with\nSELECT * FROM view_name;\n\n\n\nThe COUNT function lets us do this by returning the number of records with a value in a field.\n#How many records of birthdates are in the table people?\nSELECT COUNT (birtdates) AS count_birthdates\nFROM people;\n#for more than one field, count the number of birthdates and the number of names\nSELECT COUNT(name) AS count_names, COUNT(birthdate) AS count_birthdates\nFROM people;\n# get the number of records from a table\nSELECT COUNT(*) AS total_records\nFROM people;\nOften, our results will include duplicates. We can use the DISTINCT keyword to select all the unique values from a field.\n#get unique values in a field, how many unique languages are in the films table?\nSELECT DISTINCT language\nFROM films;\n#or use COUNT instead for get the number of distinct birthdates in a table\nSELECT COUNT(DISTINCT birthdate) AS count_dis_birth\nFROM people;\n\n\n\nUse the keyword WHERE to filter records which met certain conditions.\nFor numbers use the following operators:\n#for all titles with a release year SMALLER THAN 1960\nSELECT title\nFROM films\nWHERE release_year &lt; 1960;\n\n# for all GREATER THAN or EQUAL TO\nSELECT title\nFROM films\nWHERE release_year &gt;= 1960;\n\n#for a SPECIFIC year\nSELECT title\nFROM films\nWHERE release_year = 1960;\n\n# for all films EXCEPT 1960, NOT EQUAL TO\nSELECT title\nFROM films\nWHERE release_year &lt;&gt; 1960;\nFor strings use single-quotes:\n#for all titles that have been created in Japan\nSELECT title\nFROM films\nWHERE country = 'Japan';\nIf we want to combine WHERE with other key words, this is the order:\n#for all titles that have been created in Japan\nSELECT title\nFROM films\nWHERE country = 'Japan'\nLIMIT 5;\nMore than one condition:\n# one AND another conditions\nSELECT title\nFROM films\nWHERE country = 'Japan' AND release_year &lt;&gt; 1960;\n\n# one OR another condition is true\nSELECT title\nFROM films\nWHERE country = 'Japan' OR release_year &lt;&gt; 1960;\n\n# records are BETWEEN a range of numbers\nSELECT title\nFROM films\nWHERE release_year BETWEEN 1966 AND 1988;\n\n    # BETWEEN works inclusive, means its the same as the following\n    SELECT TITLE\n    FROM films\n    WHERE release_year &gt;= 1994\n        AND release_year &lt;= 2000'; \n\n# combine OR and AND\nSELECT title\nFROM films\nWHERE (release_year &lt;&gt; 1960 OR release_year &lt;&gt; 1961)\n    AND (certification= 'PG' OR ceritifcation = 'R');\nWhat if we are not interested that a string matches a specific word, but a pattern? We can look for this with LIKE, NOT LIKE. Therefore we use wildcards. % match zero, one or many characters. _ match a single character.\n#get all names, which started with Ad\nSELECT name\nFROM people\nWHERE name LIKE 'Ad%';\n\n#get all names, which started with Ev and has only three letters\nSELECT name\nFROM people\nWHERE name LIKE 'Ev_';\n\n#NOT LIKE is the inversion of LIKE, so it gives all records that not have a 'von' in its name\nSELECT name\nFROM people\nWHERE name NOT LIKE '%von%;\n\n# its also possible to combine the wildcards, so in a case where we want to get all names, where a 'ma' comes in the third position\nSELECT name\nFROM people\nWHERE name NOT LIKE '__ma%';\nWhat if we want to filter based on many conditions or a range of numbers? Then, we can use the IN operator, which allows us to specify multiple values in a WHERE clause, making it easier and quicker to set numerous OR conditions.\n#get all films from 1920, 1930 or 1940\nSELECT title\nFROM films\nWHERE release_year IN (1920,1930,1940);\n\n    #its the same as this but way easier:\n    SELECT title\n    FROM films\n    WHERE release_year=1920\n    OR release_year=1930\n    OR release_year=1940;\n\n#also possible for strings\nSELECT title\nFROM films\nWHERE country IN ('Germany', 'France');\n\n\n\nWhen we were learning how to use the COUNT keyword, we learned that we could include or exclude non-missing values depending on whether or not we use the asterisk in our query. But what is a missing or non-missing value? In SQL, null represents a missing or unknown value. COUNT(*) counts all records including missing values. Pay attention! COUNT(field_name counts only all given values and filter out the missings. Hence, we don’t want to jump to false conclusions, its important to access, how much data is missing. Thus, we add IS NULL to the WHERE clause. Often we want to filter out missing values. Therefore we can use IS NOT NULL.\n# how many birthdates are missing in the data base?\nSELECT COUNT(*) AS no_birthdates\nFROM people\nWHERE birthdate IS NULL;\n# if we want to filter out missing values for our counting\nSELECT COUNT(*) AS birthdates_yes\nFROM people\nWHERE birthdate IS NOT NULL;\n    # we can also filter out all null values in specifying our count\n    SELECT COUNT(birthdates) AS birthdates_yes\n    FROM people; \n\n\n\nWe already know one aggregate function, COUNT()! We’ll now learn four new aggregate functions, allowing us to find the average, sum, minimum, and maximum of a specified field, not records!\nfor numeric SUM() gives the sum AVG() gives the average\nFor various data types\nCOUNT() count the given values, can provide a total of any non-missing, or not null, records in a field regardless of their type.\nMIN() gives the minimum or MAX() gives the maximum, similarly, minimum and maximum will give the record that is figuratively the lowest or highest. Lowest can mean the letter A when dealing with strings or the earliest date when dealing with dates. And, of course, with numbers, it is the highest or the lowest number.\nBest practice is to use an alias Notice how all query results have automatically updated the field name to the function. In this case, min. It’s best practice to use an alias when summarizing data so that our results are clear to anyone reading our code.\n#for numeric data find the total duration of all films\nSELECT SUM(duration) AS total_duration\nFROM films\n\n#find the shortest film\nSELECT (duration) AS shortest_film \nFROM films;\n\n\nWe can combine aggregate functions with the WHERE clause to gain further insights from our data. That’s because the WHERE clause executes before the SELECT statement. For example, to get the average budget of movies made in 2010 or later, we would select the average of the budget field from the films table where the release year is greater than or equal to 2010.\n#get the minimum budget for all films released in 2010.\nSELECT MIN (budget) AS min_budget\nFROM films\nWHERE release_year =2010;\n\n#also possible with count, how many given values (not missing) do we have for film budgets, where films have been released in 2010?\nSELECT COUNT(budget) AS count_budget\nFROM films\nWHERE release_year = 2010;\n\n#you can also have more than one aggregate function applied\n#Modify the query to also list the average budget and average gross\nSELECT release_year,AVG(budget) AS avg_budget, AVG(gross) AS avg_gross\nFROM films\nWHERE release_year &gt; 1990\n\n\n\n\nIn SQL, we can use ROUND() to round our number to a specified decimal. There are two parameters for ROUND(): the number we want to round and the decimal place we want to round to. ROUND(number_to_round, decimal_places). decimal_places are optional. If no value is given, it treats the key word like you assigned a zero and it is rounded to a whole number. Using negative five as the decimal place parameter will cause the function to round to the hundred thousand or five places to the left. ROUND() can only be used with numerical fields.\n#let's round the average with 2 decimal places\nSELECT ROUND(AVG(budget),2) AS avg_budget\nFROM films\nWHERE release_year = 2010;\n\n\n\nWe can perform basic arithmetic with symbols like plus, minus, multiply, and divide. Using parentheses with arithmetic indicates to the processor when the calculation needs to execute.\nSimilar to other programming languages, SQL assumes that we want to get an integer back if we divide an integer by an integer. So be careful! When dividing, we can add decimal places to our numbers if we want more precision.\n#only get a whole number\nSELECT(4/3);\n\n#get one decimal place\nSELECT(4.0/3.0);\nWhat’s the difference between using aggregate functions and arithmetic? The key difference is that aggregate functions, like SUM, perform their operations on the fields vertically while arithmetic adds up the records horizontally. Notice that the query’s result doesn’t give us a defined field name. We will always need to use an alias when summarizing data with aggregate functions and arithmetic.\n# what is the gap between what a movie has made and a movie had cost?\nSELECT (gross-budget) AS profit\nFROM films;\n\nExamples.\n#Round duration_hours to two decimal places\nSELECT title, ROUND(duration / 60.0, 2) AS duration_hours\nFROM films;\n\n\n\nSorting results means we want to put our data in a specific order. It’s another way to make our data easier to understand by quickly seeing it in a sequence. Therefore, use ORDER BY. It will sort in ascending order by default (small to high number, number or special signs to A to Z). If you want to change the order to descending, than use DESC after the field name. When used on its own, itws written after the FROM statement. Attention! For numbers null / a missing value is the highest one. So you need to add a WHERE clause.\nNotice that we don’t have to select the field we are sorting on. For example, here’s a query where we sort by release year and only look at the title. However, it is a good idea to include the field we are sorting on in the SELECT statement for clarity.\n#get all titles and budgets, sorted descending by budget\nSELECT title, budget\nFROM films\nORDER BY budget DESC;\n\n#without missing values\nSELECT title, budget\nFROM films\nWHERE budget IS NOT NULL\nORDER BY budget DESC;\nORDER BY can also be used to sort on multiple fields. It will sort by the first field specified, then sort by the next, etc. To specify multiple fields, we separate the field names with a comma. The second field we sort by can be thought of as a tie-breaker when the first field is not decisive in telling the order.\n# what are the best movies? First sort by oscar wins. this is not sufficient, because several movies have won same often an oscar. Therefore, use the imdb score as a tie-breaker\nSELECT title, wins\nFROM best_movies\nWHERE budget IS NOT NULL\nORDER BY wins DESC, imdb_score DESC;\n\n# its also possible to select different orders for each field we are sorting.\nSELECT birthdate, name\nFROM people\nORDER BY birthdate, name DESC;\n\n\n\nGroup with GROUP BY. It is commonly used with aggregate functions to provide summary statistics, particularly when only grouping a single field, certification, and selecting multiple fields, certification and title. This is because the aggregate function will reduce the non-grouped field to one record only, which will need to correspond to one group.\nSQL will return an error if we try to SELECT a field that is not in our GROUP BY clause. We’ll need to correct this by adding an aggregate function around title.\nWe can use GROUP BY on multiple fields similar to ORDER BY. The order in which we write the fields affects how the data is grouped. The query here selects and groups certification and language while aggregating the title. The result shows that we have five films that have missing values for both certification and language, two films that are unrated and in Japanese, two films that are rated R and in Norwegian, and so on.\n# Example with COUNT\nSELECT certification, language, COUNT(title) AS title_count\nFROM films\nGROUP BY certification, language;\n\n#Example with AVG\nSELECT release_year, AVG(duration) AS avg_duration\nFROM films\nGROUP BY release_year;\n\n\n\n\nWe can combine GROUP BY with ORDER BY to group our results, make a calculation, and then order our results.\n#which release year has the highest language diversity?\nSELECT release_year, COUNT(DISTINCT language) AS year_diversity\nFROM films\nGROUP BY release_year\nORDER BY year_diversity DESC;\n\n\n\nWe’ve combined sorting and grouping; next, we will combine filtering with grouping. In SQL, we can’t filter aggregate functions with WHERE clauses. The reason why groups have their own keyword for filtering comes down to the order of execution. WHERE filters individual records while HAVING filters grouped records.\n# in what years was the average duration time above 2 hours?\nSELECT release_year\nFROM films\nGROUP BY release_year\nHAVING AVG(duration &gt; 120);\n#get the country with the distinct certification count greater than 10\nSELECT country, COUNT(DISTINCT(certification)) AS certification_count\nFROM films\nGROUP BY country\nHAVING COUNT(DISTINCT(certification)) &gt; 10;"
  },
  {
    "objectID": "index.html#join-data",
    "href": "index.html#join-data",
    "title": "The SQL Cheat Sheet",
    "section": "",
    "text": "Tables can have different relationsships to each other.\nThe first type of relationship we’ll talk about is a one-to-many relationship. This is the most common type of relationship, one where a single entity can be associated with several entities. Think about a music library. One artist can produce many songs over their career. This is a one-to-many relationship. The same applies for authors and their books, directors and movie titles, and so on.\nA second type of relationship is a one-to-one relationship. One-to-one relationships imply unique pairings between entities and are therefore less common. A commonly held premise of forensic science is that no two fingerprints are identical, and therefore that a particular fingerprint can only be generated by one person. This is an example of a one-to-one relationship: one fingerprint for one finger.\nThe last type of relationship we’ll discuss is a many-to-many relationship. An example of this is languages and countries. Here we show the official languages of Germany, Belgium and the Netherlands, where we see that many languages can be spoken in many countries. For example, Belgium has three official languages: French, German, and Dutch. Conversely, languages can be official in many countries: Dutch is an official language of both the Netherlands and Belgium, but not Germany.\nWith SQL joins, you can join on a key field, or any other field.\n\n\n– is for adding fields together –\nThe INNER JOIN shown looks for records in both tables with the same values in the key field, id. Arrows indicate records where the id matches. The new created table from INNER JOIN only contains records with the same values in the key field from the former tables.\n# define the fields from both tables that we want to have in our output table\nSELECT table_1.field_1, table1.field_2, table.2_field_3, table.2_field_4\n    # table, to which data should be added\nFROM table_1\nINNER JOIN tabel_2\n    # define the key field, in which the same values should be given\nON table_1.keyfield = table_2.keyfield;\nIn our INNER JOIN, we’ve had to type out “table_1” and “table_2” several times. Luckily, we can alias table names using the same AS keyword used to alias column names. If the key field is named the same in both tables, we can use USING.\n# define the fields from both tables that we want to have in our output table\nSELECT t1.field_1, t1.field_2, t2_field_3, t2_field_4\n    # table, to which data should be added\nFROM table_1 AS t1\n    # table from which data should be added\nINNER JOIN table_2 AS t2\n    # define the key field, in which the same values should be given\nUSING (key_field);\n\n#Example\n-- Select fields with aliases\nSELECT c.code AS country_code, c.name,e.year, e.inflation_rate \nFROM countries AS c\n-- Join to economies (alias e)\nINNER JOIN economies AS e\n-- Match on code field using table aliases\nON c.code = e.code;\nA powerful feature of SQL is that multiple joins can be combined and run in a single query. Let’s have a look at some syntax for multiple joins. We begin with the same INNER JOIN as before, and then chain another INNER JOIN to the result of our first INNER JOIN. Notice that we use left_table.id in the last line of this example. If we want to perform the second join using the id field of right_table rather than left_table, we can replace left_table.id with right_table.id in the final line. Only records will be in the output where the same value in the key field is given in all joined tables.\n# SYNTAX\nSELECT *\nFROM left_table\nINNER JOIN right_table\nON left_table.key = righ_table.key\nINNER JOIN next_table\nON left_table_.key/ right_table.key = next_table.key\n\n    # works also with using, here's an example\nSELECT p1.country, p1.continent,president, prime_minister,pm_start\nFROM prime_ministers AS p1\n    # second table\nINNER JOIN presidents AS p2\n    #key word for first inner join\nUSING (country)\n    # third table\nINNER JOIN prime_minister_terms AS p3\n    #key word for second inner join\nUSING (prime_minister);\nWhat if we want to inner join fields by multiple keywords? We can limit the records returned by supplying an additional field to join on by adding the AND keyword to our ON clause. In the following example we join on date, a frequently used second column when joining on multiple fields. The result set now contains records that match on both id AND date.\n# SYNTAX\nSELECT *\nFROM left_table\nINNER JOIN right_table\nON left_table.key = right_table.key\nINNER JOIN next_table\nON left_table_.key/ right_table.key = next_table.key\n    AND left_table.key2 / right_table.key2 = next.table.key2\n\n\n\nOuter joins can obtain records from other tables, even if matches are not found for the field being joined on.\nA LEFT JOIN will return all records in the left_table, and those records in the right_table that match on the joining field provided. Records that are only in the right table provided will faded out. For records, that only appear in the left table, the missing values are set to null in the joined table. LEFT JOIN can also be written as LEFT OUTER JOIN.\n# SYNTAX\nSELECT p1.country, prime_minister, president\nFROM prime_ministers AS p1\nLEFT JOIN presidents AS p2\nUSING (country);\nRIGHT JOINis the second type of outer join, and is much less common than LEFT JOIN so we won’t spend as much time on it here. Instead of matching entries in the id column of the left table to the id column of the right table, a RIGHT JOIN does the reverse. All records are retained from right_table, even when id doesn’t find a corresponding match in left_table. Null values are returned for the left_value field in records that do not find a match.\n# SYNTAX\nSELECT *\nFROM left_table\nLEFT JOIN right table\nON left_table_key = right_table_key; \n\n\n\nA FULL JOIN combines a LEFT JOIN and a RIGHT JOIN. As you can see in this diagram, no values are faded out as they were in earlier diagrams. This is because the FULL JOIN will return all ids, irrespective of whether they have a match in the other table being joined. Note that this time, nulls can appear in either left_value or right_value fields. Note that the keyword FULL OUTER JOIN can also be used to return the same result.\n# SYNTAX\nSELECT left_table_id AS l_id, right_table_id, AS r_idf, left_table_val AS l_val, right_table_val AS r?val\nFROM left_table\nFULL JOIN right table\nUSING id;\n\n\n\nCROSS JOINs are slightly different than joins we have seen previously: they create all possible combinations of two tables. Let’s explore the diagram for a CROSS JOIN. In this diagram we have two tables named table1 and table2, with one field each: id1 and id2, respectively. The result of the CROSS JOINis all nine combinations of the id values of 1, 2, and 3 in table1 with the id values of A, B, and C for table2.\n# SYNTAX\nSELECT field1, field2\nFROM table 1\nCROSS JOIN table 2;\n\n\n\nSelf joins are used to compare values from part of a table to other values from within the same table. Self joins don’t have dedicated syntax as other joins we have seen do. We can’t just write SELF JOIN in SQL code, for example.\nIn addition, aliasing is required for a self join. Let’s look at a chunk of INNER JOIN code using the prime_ministers table. The country column is selected twice, and so is the continent column. The prime_ministers table is on both the left and the right of the JOIN, making this both a self join and an INNER JOIN! The vital step here is setting the joining fields which we use to match the table to itself. For each country, we will find multiple matched countries in the right table, since we are joining on continent. Each of these matched countries will be returned as pairs. Since this query will return several records, we use LIMIT to return only the first 10 records.\n# SYNTAX\nSELECT p1.country AS country1, p2.country AS country2, p1.continent\nFROM prime_ministers AS p1\nINNER JOIN prime_minister AS p2\nON p1.continent = p2.continent\nLIMIT 10;\nThe results are a pairing of each country with every other country in the same continent. However, note that our join also paired countries with themselves, since they too are in the same continent as themselves. We don’t want to include these, since a leader from Portugal does not need to meet with themselves, for example. Let’s fix this. Recall the use of the AND clause to ensure multiple conditions are met in the ON clause. In our second condition, we use the not equal to operator to exclude records where the p1-dot-country and p2-dot-country fields are identical.\n# SYNTAX\nSELECT p1.country AS country1, p2.country AS country2, p1.continent\nFROM prime_ministers AS p1\nINNER JOIN prime_minister AS p2\nON p1.continent = p2.continent\n    # not equal to\n    AND p1.continent &lt;&gt; p2.continent\nLIMIT 10;\n\n\n\nSQL has three main set operations, UNION, INTERSECT and EXCEPT. The Venn diagrams shown visualize the differences between them. We can think of each circle as representing a table. The green parts represent what is included after the set operation is performed on each pair of tables.\n\n\n\n– is for adding records together –\nIn SQL, the UNION operator takes two tables as input, and returns all records from both tables. The diagram shows two tables: left and right, and performing a UNION returns all records in each table. If two records are identical, UNION only returns them once. In SQL, there is a further operator for unions called UNION ALL. In contrast to UNION, given the same two tables, UNION ALL will include duplicate records.\n# SYNTAX\nSELECT t1.field1, t2.field2\nFROM table_1 AS t1\nUNION\nSELECT t1.field1, t2.field2\nFROM table_2 AS t2;\nFor all set operations, the number of selected columns and their respective data types must be identical. For instance, we can’t stack a number field on top of a character field. The result will only use field names (or aliases, if used) of the first SELECT statement in the query.\n\n\n\n\nINTERSECT takes two tables as input, and returns only the records that exist in both tables.\n# SYNTAX\nSELECT t1.field1, t2.field2\nFROM table_1 AS t1\nINTERSECT\nSELECT t1.field1, t2.field2\nFROM table_2 AS t2;\nLet’s compare INTERSECT to performing an INNER JOIN on two fields with identical field names. Similar to UNION, for a record to be returned, INTERSECT requires all fields to match, since in set operations we do not specify any fields to match on. This is also why it requires the left and right table to have the same number of columns in order to compare records. In the figure shown, only records where both columns match are returned. In NNER JOIN, similar to INTERSECT, only results where both fields match are returned. INNER JOIN will return duplicate values, whereas INTERSECT will only return common records once. As we know from earlier lessons, INNER JOIN will add more columns to the result set.\n\n\n\n\nEXCEPT allows us to identify the records that are present in one table, but not the other. More specifically, it retains only records from the left table that are not present in the right table.\n# SYNTAX\nSELECT t1.field1, t2.field2\nFROM table_1 AS t1\nEXCEPT\nSELECT t1.field1, t2.field2\nFROM table_2 AS t2;"
  },
  {
    "objectID": "index.html#data-manipulation",
    "href": "index.html#data-manipulation",
    "title": "The SQL Cheat Sheet",
    "section": "",
    "text": "CASE statements are SQL’s version of an “IF this THEN that” statement. Case statements have three parts – a WHEN clause, a THEN clause, and anELSE clause. The first part – the WHEN clause – tests a given condition, say, x = 1. If this condition is TRUE, it returns the item you specify after your THEN clause. You can create multiple conditions by listing WHEN and THEN statements within the same CASE statement. The CASE statement is then ended with an ELSE clause that returns a specified value if all of your when statements are not true. When you have completed your statement, be sure to include the term END and give it an alias. The completed CASE statement will evaluate to one column in your SQL query.\n#Identify the home team as Bayern Munich, Schalke 04, or neither\n    #select the hometeam_ids that belongs to the temas and give them the right name\nSELECT \n    CASE WHEN hometeam_id = 10189 THEN 'FC Schalke 04'\n        WHEN hometeam_id = 9823 THEN 'FC Bayern Munich'\n    #select how the others should be called which do not met the condition and define the alias for the field_name of the new table\n         ELSE 'Other' END AS home_team,\n    #count the number of matches and call them total_matches as a field name\n    COUNT(id) AS total_matches\n    #define the table\nFROM matches_germany\n    # Group by the CASE statement alias\nGROUP BY home_team;\n\n# Select the date of  all matches in Spain and identify whether home wins, losses or ties\nSELECT \n    date,\n    CASE WHEN home_goal &gt; away_goal THEN 'Home win!'\n        WHEN home_goal &lt; away_goal THEN 'Home loss :(' \n        ELSE 'Tie' END AS outcome\nFROM matches_spain;\n\n\nPreviously, we covered CASE statements with one logical test in a WHEN statement, returning outcomes based on whether that test is TRUE or FALSE. The former example tests whether home or away goals were higher, and identifies them as wins for the team that had a higher score. Everything ELSE is categorized as a tie. The resulting table has one column identifying matches as one of 3 possible outcomes.\nIf you want to test multiple logical conditions in a CASE statement, you can use AND inside your WHEN clause. For example, let’s see if each match was played, and won, by the team Chelsea. Let’s see the CASE statement in this query. Each WHEN clause contains two logical tests – the first tests if a hometead_id identifies Chelsea, AND then it tests if the home team scored higher than the away team. If both conditions are TRUE, the new column output returns the phrase “Chelsea home win!”. The opposite set of conditions are included in a second when statement – if the awayteam_id belongs to Chelsea, AND scored higher, then the output returns “Chelsea away win!”. All other matches are categorized as a loss or tie. Here’s the resulting table.\n#Example\n#select the date and the ids for the team\nSELECT date, hometeam_id, awayteam_id\n    #test on multiple logical conditions with AND\n    CASE WHEN hometeam_id = 8455 AND home_goal&gt; away_goal THEN 'Chelsea home win!'\n            WHEN awayteam_id = 8455 AND home_goal &lt; away_goal THEN 'Chelsea away win!'\n    ELSE 'Loss or tie:(' END AS outcome\n# define table\nFROM match\n# filter only for records, that you are interested in\nWHERE hometeam_id 8455 OR awayteam_id = 8455;\n\n\n\nWhen testing logical conditions, it’s important to carefully consider which rows of your data are part of your ELSE clause, and if they’re categorized correctly. Here’s the same CASE statement from the previous slide, but the WHERE filter has been removed. Without this filter, your ELSE clause will categorize ALL matches played by anyone, who don’t meet these first two conditions, as “Loss or tie :(”.\n#Example\n#select the date and the ids for the team\nSELECT date, hometeam_id, awayteam_id\n    #test on multiple logical conditions with AND\n    CASE WHEN hometeam_id = 8455 AND home_goal&gt; away_goal THEN 'Chelsea home win!'\n            WHEN awayteam_id = 8455 AND home_goal &lt; away_goal THEN 'Chelsea away win!'\n    ELSE 'Loss or tie:(' END AS outcome\n# define table\nFROM match\n#return all matches and without the filter, all matches without Chelsea are defined as loss or tie\nThe easiest way to correct for this is to ensure you add specific filters in the WHERE clause that exclude all teams where Chelsea did not play. Here, we specify this by using an OR statement in WHERE, which retrieves only results where the id 8455 is present in the hometeam_id or awayteam_id columns. The resulting table from earlier, with the team IDs in bold here, clearly specifies whether Chelsea was home or away team.\n\n\n\nThese two queries here are identical, except for the ELSE NULL statement specified in the second. They both return identical results – a table with quite a few null results. But what if you want to exclude them?\n#without ELSE\nSELECT date,\n    CASE WHEN date&gt; '2015-01-01' THEN 'more recently'\n        WHEN date &lt; '2012-01-01' THEN 'older'\n        END AS date_category\nFROM match;\n\n#with\nSELECT date,\n    CASE WHEN date&gt; '2015-01-01' THEN 'more recently'\n        WHEN date &lt; '2012-01-01' THEN 'older'\n        ELSE NULL END AS date_category\nFROM match;\nLet’s say we’re only interested in viewing the results of games where Chelsea won, and we don’t care if they lose or tie. Just like in the previous example, simply removing the ELSE clause will still retrieve those results – and a lot of NULL values. To correct for this, you can treat the entire CASE statement as a column to filter by in your WHERE clause, just like any other column. In order to filter a query by a CASE statement,\n#Example\n#select the date and the ids for the team\nSELECT date, hometeam_id, awayteam_id\n    #test on multiple logical conditions with AND\n    CASE WHEN hometeam_id = 8455 AND home_goal&gt; away_goal THEN 'Chelsea home win!'\n            WHEN awayteam_id = 8455 AND home_goal &lt; away_goal THEN 'Chelsea away win!'\n    #no ELSE, because we want to have the NULLs in here\n# define table\nFROM match\n# filter only for records, without NULL values at all\nWHERE     CASE WHEN hometeam_id = 8455 AND home_goal&gt; away_goal THEN 'Chelsea home win!'\n            WHEN awayteam_id = 8455 AND home_goal &lt; away_goal THEN 'Chelsea away win!'\n    END IS NOT NULL;\n\n\n\nCASE statements can be used to create columns for categorizing data, and to filter your data in the WHERE clause. You can also use CASE statements to aggregate data based on the result of a logical test.\nCASE statements are like any other column in your query, so you can include them inside an aggregate function. Take a look at the CASE statement. The WHEN clause includes a similar logical test to the previous lesson – did Liverpool play as the home team, AND did the home team score higher than the away team? The difference begins in your THEN clause. Instead of returning a string of text, you return the column identifying the unique match id.\n# What is the number of home games Liverpool (8650) won in each seasion?\nSELECT season,\n    #count only the rows where liverpool has won as a home team\nCOUNT( CASE WHEN home_id = 8650\n                AND home_goal &gt; away_goal THEN id END) AS home_wins\nFROM match\n    #each season\nGROUP BY season;\nSimilarly, you can use the SUM function to calculate a total of any value.\n# what is the number of home and away goals Liverpool scored in each season?\nSELECT season,\n    SUM (CASE WHENhometeam_id= 8650\n            THEN home_goal END) AS home_goals,\n    SUM(CASE WHEN awayteam_id = 8650\n        THEN away_goal END) AS away_goals\nFROM match\n    #each season\nGROUP BY season;\nYou can also use the AVG function with CASE in two key ways. First, you can calculate an average of data. You can do this using CASE in the EXACT same way you used the SUM function.\n# what was the average goals in each season?\nSELECT season,\n    SUM (CASE WHENhometeam_id= 8650\n            THEN home_goal END) AS home_goals,\n    SUM(CASE WHEN awayteam_id = 8650\n        THEN away_goal END) AS away_goals\nFROM match\n    #each season\nGROUP BY season;\n\n#or another way: round it!\nSELECT season,\n    ROUND(AVG(CASE WHEN hometeam_id=8650\n                #round it by two digits\n                THEN home_goal END,2) AS avg_homegoals\n    ROUND(AVG(CASE WHEN awayteam_id=8650\n                #round it by two digits\n                THEN away_goal END,2) AS avg_awaygoals\nFROM match\nGROUB BY season;\nThe second key application of CASE with AVG is in the calculation of percentages. This requires a specific structure in order for your calculation to be accurate.\n# What is the percentage of Liverpools games did they win in each season?\n#select season to be displayed\nSELECT season,\n    #how many games they win as a home team?\n        #the wins\n    ROUND(AVG (CASE WHEN hometeam_id= 8650 AND home_goal &gt; away_goal THEN 1\n            #the losts\n     CASE WHEN hometeam_id= 8650 AND home_goal &lt; away_goal\n            THEN 0 END,2)\n        #averages the wins (1) and losts (0)\n        AS pct_homewins,\n     ROUND(   AVG (CASE WHEN awayteam_id= 8650 AND away_goal &gt; home_goal THEN 1\n            #the losts\n     CASE WHEN awayteam_id= 8650 AND away_goal &lt; home_goal\n            THEN 0 END,2)\n        #averages the wins (1) and losts (0)\n        AS pct_awaywins,\nFROM match\n    #each season\nGROUP BY season;"
  },
  {
    "objectID": "index.html#subqueries-for-data-manipulation",
    "href": "index.html#subqueries-for-data-manipulation",
    "title": "The SQL Cheat Sheet",
    "section": "",
    "text": "A subquery is a query nested inside another query. You can tell that there is a subquery in your SQL statement if you have an additional SELECT statement contained inside parentheses, surrounded by another complete SQL statement. So why is this important? Often, in order to retrieve information you want, you have to perform some intermediary transformations to your data before selecting, filtering, or calculating information. Subqueries are a common way of performing this transformation.\n#SYNTAX\nSELECT column\nFROM (SELECT column\n    FROM table) AS subquery;\nA subquery can be placed in any part of your query – such as the SELECT, FROM, WHERE, or GROUP BY clause. Where you place it depends on what you want your final data to look like.\n- Subqueries allow you to compare summarized values to detailed data. For example, compare Liverpool’s performance to the entire English Premier League - Subqueries also allow you to better structure or reshape your data for multiple purposes, such as determining the highest monthly average of goals scored in the Bundesliga. - Finally, subqueries allow you to combine data from tables where you are unable to perform a join, such as getting both the home and away team names into your results table.\nA simple subquery is a query, nested inside another query, that can be run on its own.\nA simple subquery is also evaluated once in the entire query. This means that SQL first processes the information inside the subquery, gets the information it needs, and then moves on to processing information in the OUTER query.\n\n\n\nuseful for filtering results based on information you’d have to calculate separately beforehand.\nonly return a single column\nSubqueries inside WHERE can be from the same table or from a different table\ncould be another way to join information of tables without using join. Now, it is possible to filter the data of one table based on values which are given in another table\n\nWorkflow: - include a SQL subquery as an argument for the IN operator, provided the result of the subquery is of the same data type as the field we are filtering on. - only work if some_field is of the same data type as some_numeric_field, because the result of the subquery will be a numeric field.\nSELECT *\nFROM some_table\nWHERE some_field IN\n    (include subquery here);\nExample: What home_goals where above the average in 2012/2013?\nSELECT date, home_id, away_id, home_goal, away_goal\nFROM match\nWHERE season = '2012/2013'\n    home_goal &gt; \n    #you can run this part on its own!!\n        (SELECT AVG(home_goal)\n         FROM match);\nSubqueries are also useful for generating a filtering list. Example: “Which teams are part of Poland’s league?”\nSELECT team_long_name, team_short_name AS abbr\nFROM team\nWHERE team_api_id IN\n    #filter for poland\n    SELECT home_id\n    FROM match\n    WHERE country_id = 157222);\nThe subquery in WHERE is processed first, generating the overall average of home goals scored. SQL then moves onto the main query, treating the subquery like the single, aggregate value it just generated.\nAnother example, how you can use subqueries to filter one table based on information from another. Determining the presidents of countries that gained independence before 1800.\n# Example\nSELECT president, country, continent\nFROM presidents\nWHERE country IN\n(SELECT country\nFROM states\nWHERE indep_year &lt;1800;\nAlso possible the other way around! The anti join chooses records in the first table where col1 does NOT find a match in col2. Example: How might we adapt our semi join to determine countries in the Americas founded after 1800?\n# Example\nSELECT president, country, continent\nFROM presidents\nWHERE continent LIKE '%Amerika\"\n    AND country NOT IN\n(SELECT country\nFROM states\nWHERE indep_year &lt;1800;\n\n\n\n\nuseful for more complex set of results\nrobust tool for restructuring and transforming your data in a different shape (long to wide format)\nprefilitering before performing calculations\ncalculating aggregates\n\nExample for filtering: all the continents with monarchs, along with the most recent country to gain independence in that continent.\n#Start with pulling the most recent independence years\nSELECT continent, MAX(indep_year) AS most_recent\nFROM states\nGROUP BY continent;\n\n# filter for countries, that have a monarch using SELECT DISTINCT and WHERE to combine the tables and get only the rows, where a row is also given in the monarchs table\nSELECT DISTINCT monarchs.continent, sub.most_recent\nFROM monarchs,\n    (SELECT continent\n     MAX(indep_year) AS most_recent\nFROM states\nGROUP BY continent AS sub\nWHERE monarchs.continent = sub.continent\nExample for averaging: get the top 3 teams based home goal average for each team in data base for season 2011/2012.\n#first create a query, that become the subquery\nSELECT\n    t.team_long_name AS team,\n    AVG (m.home_goal) AS home_avg\nFROM match AS m\nLEFT JOIN team AS t\nON m.home-team_id = t.team_api_id\nWHERE season = '2011/2012'\nGROUP BY team;\n\n#second, to get the top teams only, place this query in a FROM statement of an outer query and give it an alias\nFROM (SELECT\n    t.team_long_name AS team,\n    AVG (m.home_goal) AS home_avg\nFROM match AS m\nLEFT JOIN team AS t\nON m.home-team_id = t.team_api_id\nWHERE season = '2011/2012'\nGROUP BY team) as subquery\n\n#third, add the main query, seceting the team and the home_avg and order them by home_avg, limit with 3 to get only the 3 top results displayes\nSELECT team, home_avg\nFROM (SELECT\n    t.team_long_name AS team,\n    AVG (m.home_goal) AS home_avg\nFROM match AS m\nLEFT JOIN team AS t\nON m.home-team_id = t.team_api_id\nWHERE season = '2011/2012'\nGROUP BY team) as subquery\nORDER BY home_avg DESC\nLIMIT 3;\nTo remember: - you can create multiple subqueries in one FROM statement, give all of them an ALIAS, make sure you are able to join them to each other - you can join a subquery to an existing data base, needs a joining column in both tables!\n\n\n\n\nreturn single, aggregated value\nfairly useful, cause uou cannot include an aggragte value in an ungrouped query\nuseful for performing complex mathematical calculations, e.g. to calculate how an individual score deviates from an average\n\nExample for including aggregates: compare total number of matches played each season with the total number of matches overall.\n#SYNTAX\n# overall number\nSELECT COUNT(id)\nFROM matches;\n\n# add this subquery directly to the select statement\nSELECT season,\n    #for the match each season (combined with the grouping keyword\nCOUNT(id) AS matches,\n(SELECT COUNT(id) FROM match) as total_matches\nFROM match\nGROUP BY season;\nExample for calculations: difference between the overall average numbers of goals scored in a match across all seasons and any given match\n#main query\nSELECT date,\n    #subquery 1: all goals in a game\n(home_goal + away_goal) AS goals,\n    #subquery 2: difference between the goals and the overall average)\n(home_goal + away_goal) - (SELECT(AVG(home_goal + away_goal)  FROM match WHERE season = '2011/2012' AS diff\nFROM match\nWHERE season = '2011/2012';\nTo remember: - subquery needs to return a single value, because information computed in the SELECT query is applied identically to each row in a data set - correct placement of data filters in both the main query and the subquery\n\n\n\nBest practices for readability: - formatting your queries - annotate your with /* what it does, use inline comments -- - indent your queries for better debugging. Make sure that you clearly indent all information that’s part of a single column, such as a long CASE statement, or a complicated subquery in SELECT. - make sure that your filters are properly placed in every subquery, and the main query, in order to generate accurate results."
  }
]